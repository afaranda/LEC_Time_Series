rl<- rl * ifelse(ft[ft[,ft_id] == s, ReadLen], 2, 1)
}
gt$l<-gt$l - rl + 1
}
rpkm <- x / gt$l
rpkm <- (rpkm * 10^9) /sum(x)
rpkm
}
for(s in colnames(mat)){
print(s)
mat[,s]<-norm(mat[,s], s)
}
gt<-genes
for(s in colnames(mat)){
print(s)
mat[,s]<-norm(mat[,s], s)
}
# Normalize a count matrix to account TPM or FPKM based on Exon Union length
# Optionally account for read lengths and paired / single endedness
normGeneLength<-function(
mat,                    # Count matrix to normalize
ft = ft,                # File table with th sample metadata
ft_id = "Sample",       # Name of column in "ft" listing sample ID's
gt = genes,             # Table of gene metadata
gt_id = "gene_id",      # Name of column gt listing gene ID's
gt_ln = "Union_Length", # Name of column listing gene lengths
TPM = T,                # If true calculate TPM, otherwise FPKM
ReadLen = NULL,         # If not null, Column in "ft" with Read Lengths
Paired  = NULL          # If not null, Column in "ft" paired vs single
) {
if(TPM){
norm<-function(x, s){
rl <- 0
gt$l <-gt[,gt_ln]
if(!is.null(ReadLen)){
rl<-ft[ft[,ft_id] == s, ReadLen]
if(!is.null(Paired)){
rl<- rl * ifelse(ft[ft[,ft_id] == s, ReadLen], 2, 1)
}
gt$l<-gt$l - rl + 1
}
tpm <- x / gt$l
tpm <- (tpm * 10^6)/sum(tpm)
tpm
}
for(s in colnames(mat)){
print(s)
mat[,s]<-norm(mat[,s], s)
}
return(mat)
} else {
norm<-function(x, s){
rl <- 0
gt$l <-gt[,gt_ln]
if(!is.null(ReadLen)){
rl<-ft[ft[,ft_id] == s, ReadLen]
if(!is.null(Paired)){
rl<- rl * ifelse(ft[ft[,ft_id] == s, ReadLen], 2, 1)
}
gt$l<-gt$l - rl + 1
}
rpkm <- x / gt$l
rpkm <- (rpkm * 10^9) /sum(x)
rpkm
}
for(s in colnames(mat)){
print(s)
mat[,s]<-norm(mat[,s], s)
}
return(mat)
}
}
gt_id = "gene_id"
gt_ln = "Union_Length"
for(s in colnames(mat)){
print(s)
mat[,s]<-norm(mat[,s], s)
}
ReadLen = NULL
for(s in colnames(mat)){
print(s)
mat[,s]<-norm(mat[,s], s)
}
for(s in colnames(mat)){
print(s)
#mat[,s]<-norm(mat[,s], s)
}
for(s in colnames(mat)){
print(s)
#mat[,s]<-norm(mat[,s], s)
}
for(s in colnames(mat)){
print(s)
#mat[,s]<-norm(mat[,s], s)
}
colnames(mat)
mat
head(mat)
head(mat)
class(mat)
class(htseq_count[[2]])
mat<-htseq_count[[2]]
head(mat)
for(s in colnames(mat)){
print(s)
#mat[,s]<-norm(mat[,s], s)
}
for(s in colnames(mat)){
print(s)
mat[,s]<-norm(mat[,s], s)
}
# Normalize a count matrix to account TPM or FPKM based on Exon Union length
# Optionally account for read lengths and paired / single endedness
normGeneLength<-function(
mat,                    # Count matrix to normalize
ft = ft,                # File table with th sample metadata
ft_id = "Sample",       # Name of column in "ft" listing sample ID's
gt = genes,             # Table of gene metadata
gt_id = "gene_id",      # Name of column gt listing gene ID's
gt_ln = "Union_Length", # Name of column listing gene lengths
TPM = T,                # If true calculate TPM, otherwise FPKM
ReadLen = NULL,         # If not null, Column in "ft" with Read Lengths
Paired  = NULL          # If not null, Column in "ft" paired vs single
) {
mat<-as.data.frame(mat)
if(TPM){
norm<-function(x, s){
rl <- 0
gt$l <-gt[,gt_ln]
if(!is.null(ReadLen)){
rl<-ft[ft[,ft_id] == s, ReadLen]
if(!is.null(Paired)){
rl<- rl * ifelse(ft[ft[,ft_id] == s, ReadLen], 2, 1)
}
gt$l<-gt$l - rl + 1
}
tpm <- x / gt$l
tpm <- (tpm * 10^6)/sum(tpm)
tpm
}
for(s in colnames(mat)){
print(s)
mat[,s]<-norm(mat[,s], s)
}
return(mat)
} else {
norm<-function(x, s){
rl <- 0
gt$l <-gt[,gt_ln]
if(!is.null(ReadLen)){
rl<-ft[ft[,ft_id] == s, ReadLen]
if(!is.null(Paired)){
rl<- rl * ifelse(ft[ft[,ft_id] == s, ReadLen], 2, 1)
}
gt$l<-gt$l - rl + 1
}
rpkm <- x / gt$l
rpkm <- (rpkm * 10^9) /sum(x)
rpkm
}
for(s in colnames(mat)){
print(s)
mat[,s]<-norm(mat[,s], s)
}
return(mat)
}
}
normGeneLength(htseq_count[[2]], ft=htseq_count[[1]], TPM=F)
x<-normGeneLength(htseq_count[[2]], ft=htseq_count[[1]], TPM=F)
head(x)
x<-normGeneLength(htseq_count[[2]], ft=htseq_count[[1]], TPM=T)
head(x)
ft
# Add Class attribute to feature definition table
ft<-htseq_count[[1]]
ft$Class<-as.factor(paste("Hour",ft$Hours_PCS,sep=""))
ft$Class<-factor(
ft$Class,
levels=unique(
as.character(ft$Class[order(ft$Hours_PCS)])
)
)
mat<-htseq_count[[2]]
ft<-htseq_count[[1]]
ft$Class<-as.factor(paste("Hour",ft$Hours_PCS,sep=""))
ft$Class<-factor(
ft$Class,
levels=unique(
as.character(ft$Class[order(ft$Hours_PCS)])
)
)
mat<-htseq_count[[2]]
genes<-ly %>% group_by(gene_id) %>% filter(row_number()==1)
genes<-lt %>% group_by(gene_id) %>% filter(row_number()==1)
x<-normGeneLength(htseq_count[[2]], ft=htseq_count[[1]], TPM=T)
htseq_count[[2]][grep("__",row.names(htseq_count[[2]])),]
htseq_count[[2]][grep("ENS",row.names(htseq_count[[2]])),]
htseq_count[[2]][grep("_",row.names(htseq_count[[2]])),]
ecpm<-edgeRcpm(mat)                     # Normalize using edgeR's TMM method
etpm<-normGeneLength(ft, mat, genes= )
etpm<-normGeneLength(ft, mat, gt=genes)
etpm<-normGeneLength(ft=ft, mat=mat, gt=genes)
head(etpm)
ecmb<-wrapCombat(ecpm, ft)                 # Correct for batch effects
ft
ecmb<-wrapCombat(ecpm, ft, groupCol = "Class")                 # Correct for batch effects
ecmb<-wrapCombat(ecpm, ft, groupCol = 9)                 # Correct for batch effects
ft
ecmb<-wrapCombat(ecpm, ft, groupCol = 9, batchCol = 6)                 # Correct for batch effects
model.matrix(~0+Class, ft)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~0+Class, ft)
)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab
)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~Genotype, ft)
)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~Genotype, ft)
)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~0+Genotype, ft)
)
ft$Lab
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~0+Genotype, ft)
)
model.matrix(~0+Genotype, ft)
model.matrix(~0+Genotype, ft)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~0+Class, ft)
)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~1)
)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~1, ft)
)
model.matrix(~1, ft)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~0+Class, ft)
)
ecmb<-ComBat(
dat = mat,
batch = ft$Lab)
any(is.na(matrix(data, nrow = rows, ncol = cols)))
any(is.na(mat))
ecmb<-ComBat(
dat = mat,
batch = ft$Lab,
mod = model.matrix(~1, ft)
)
setwd('/home/adam/Documents/LEC_Time_Series')
library(dplyr)
library(cluster)
library(reshape2)
wd<-getwd()
source('transcriptomic_analysis_scripts/BuildDataMatrix.R')
source('transcriptomic_analysis_scripts/PreprocessingFunctions.R')
source('transcriptomic_analysis_scripts/PrincipalComponents.R')
source('transcriptomic_analysis_scripts/ClusteringFunctions.R')
gtfpath<-"/home/adam/Documents/LTS_Data/Mus_musculus.GRCm38.96.chr.gtf"
orig_gtf<-readGFF(gtfpath)
dl<-c(
"/home/adam/Documents/LTS_Data/DBI_NoTrim_HTSeq_Count_Gene",
"/home/adam/Documents/LTS_Data/DNA_Link_NoTrim_HTSeq_Count_Gene"
)
if(length(list.files(pattern = "GeneLengthTable.Rdata"))>0){
load("GeneLengthTable.Rdata")
} else {
lt<-lengthTable(gtfpath)
}
ft<-hc_getFileTable(dirList=dl)
ds<-hc_loadFiles(ft)
ft<-hc_identifierConsistency(ds, ft)
htseq_count<-hc_buildDataFrame(ds, ft)
htseq_count<-hc_dropSamples(
ft = htseq_count[[1]],
mat = htseq_count[[2]],
samples = ft[ft$Genotype !="WT", 1]
)
htseq_dge<-buildDGE(htseq_count[[2]], ft=htseq_count[[1]],
gt=data.frame(lt %>%
group_by(gene_id) %>%
summarise(Union_Length = dplyr::first(Union_Length)
)
)
)
# Add Class attribute to feature definition table
ft<-htseq_count[[1]]
ft$Class<-as.factor(paste("Hour",ft$Hours_PCS,sep=""))
ft$Class<-factor(
ft$Class,
levels=unique(
as.character(ft$Class[order(ft$Hours_PCS)])
)
)
mat<-htseq_count[[2]]
genes<-lt %>% group_by(gene_id) %>% filter(row_number()==1)
ecpm<-edgeRcpm(mat)                     # Normalize using edgeR's TMM method
etpm<-normGeneLength(ft=ft, mat=mat, gt=genes)
ecmb<-wrapCombat(ecpm, ft, groupCol = 9, batchCol = 6, idCol = 0)# Correct for batch effects
ecmb<-fixCombatNegatives(ecmb, idCol=0)             # replace negative values with min +ve
etpm[etpm==0]
etpm[etpm==0]<-0.0001
etmb<-ComBat(
dat=as.matrix(etpm),
batch=ft$Lab,
mod = model.matrix(~1, ft)
)
etmb<-fixCombatNegatives(etmb, idCol =0)
############ Analyze Sample Clusters at desired Variance Threshold #############
distm <-c('euclidean', 'manhattan')			  # Try different distance methods
linkm <-c('complete', 'average', 'single')    # Try different linkage methods
trees <-c(1,2,3,4,5,6)                        # Different levels k
v =200
ecpm.filter<-varianceFilter(ecpm, threshold=v)
ecmb.filter<-varianceFilter(ecmb, threshold=v)
clustStats<-rbind(
summarizeSampleClusters(
data=ecpm, distm=distm, linkm=linkm, v=v, label='ecpm'
),
summarizeSampleClusters(
data=ecmb, distm=distm, linkm=linkm, v=v, label='ecmb'
)
)
ncol(mat)
clustStats<-rbind(
summarizeSampleClusters(
data=ecpm, distm=distm, linkm=linkm, v=v, label='ecpm'
),
summarizeSampleClusters(
data=ecmb, distm=distm, linkm=linkm, v=v, label='ecmb'
)
)
summarizeSampleClusters<-function(data=ecpm, distm, linkm, v=50, label='ecpm'){
data<-varianceFilter(data, threshold=v)
row.names(data)<-data$ID
for(d in distm){
for(l in linkm){
f1<-paste(label,'_Samples_Top_', v,'_',d,'_',l,'_cluster.png')
mat<-data[,1:18]
h1<-wrapHclust(mat,
idCol=0, transpose=T, d.meth=d, h.method = l
)
print(h1)
kt1<-tabulate_H_Clusters(h1, ks = trees)
kt1$I<-row.names(kt1)
kt1$TC<-sapply(kt1$I, function(i) ft[ft$Sample_Number ==i, 'Class'])
kt1$TC<-sapply(kt1$I, function(i) ft[ft$Sample_Number ==i, 'Seq_Lab'])
png(f1, width=240, height=200)
plotHclust(h1, ft, sampleCol=7, labelCol=8, colorCol=4, main='')
dev.off()
for(t in trees){
r<-randIndex(kt1, length(trees)+1, t, length(trees)+2)
if(t > 1){
sil<-as.data.frame(
silhouette(
cutree(h1, t),
dist(t(mat), method= d)
)[,1:3]
)
sm<-mean(sil$sil_width)
sil<-sil %>%
group_by(cluster) %>%
summarize( mean(sil_width), n())
slist<-paste(sil$`n()`, '(',round(sil$`mean(sil_width)`,3),')',sep='')
print(slist)
}
else{
sm<-0
slist<-"None"
}
if(!exists('randTable')){
randTable<-data.frame(
Data = label,
DistMethod = d,
LinkMethod = l,
NumClusters= t,
RandIndex = r,
MeanSilhouette=sm,
ClusterSilhouettes=paste(slist, collapse=', '),
stringsAsFactors=F
)
}
else{
randTable<-rbind(
randTable,
data.frame(
Data = label,
DistMethod = d,
LinkMethod = l,
NumClusters= t,
RandIndex = r,
MeanSilhouette=sm,
ClusterSilhouettes=paste(slist, collapse=', '),
stringsAsFactors=F
)
)
}
}
}
}
randTable
}
clustStats<-rbind(
summarizeSampleClusters(
data=ecpm, distm=distm, linkm=linkm, v=v, label='ecpm'
),
summarizeSampleClusters(
data=ecmb, distm=distm, linkm=linkm, v=v, label='ecmb'
)
)
summarizeSampleClusters<-function(data=ecpm, distm, linkm, v=50, label='ecpm'){
data<-varianceFilter(data, threshold=v)
#row.names(data)<-data$ID
for(d in distm){
for(l in linkm){
f1<-paste(label,'_Samples_Top_', v,'_',d,'_',l,'_cluster.png')
mat<-data[,1:18]
h1<-wrapHclust(mat,
idCol=0, transpose=T, d.meth=d, h.method = l
)
print(h1)
kt1<-tabulate_H_Clusters(h1, ks = trees)
kt1$I<-row.names(kt1)
kt1$TC<-sapply(kt1$I, function(i) ft[ft$Sample_Number ==i, 'Class'])
kt1$TC<-sapply(kt1$I, function(i) ft[ft$Sample_Number ==i, 'Seq_Lab'])
png(f1, width=240, height=200)
plotHclust(h1, ft, sampleCol=7, labelCol=8, colorCol=4, main='')
dev.off()
for(t in trees){
r<-randIndex(kt1, length(trees)+1, t, length(trees)+2)
if(t > 1){
sil<-as.data.frame(
silhouette(
cutree(h1, t),
dist(t(mat), method= d)
)[,1:3]
)
sm<-mean(sil$sil_width)
sil<-sil %>%
group_by(cluster) %>%
summarize( mean(sil_width), n())
slist<-paste(sil$`n()`, '(',round(sil$`mean(sil_width)`,3),')',sep='')
print(slist)
}
else{
sm<-0
slist<-"None"
}
if(!exists('randTable')){
randTable<-data.frame(
Data = label,
DistMethod = d,
LinkMethod = l,
NumClusters= t,
RandIndex = r,
MeanSilhouette=sm,
ClusterSilhouettes=paste(slist, collapse=', '),
stringsAsFactors=F
)
}
else{
randTable<-rbind(
randTable,
data.frame(
Data = label,
DistMethod = d,
LinkMethod = l,
NumClusters= t,
RandIndex = r,
MeanSilhouette=sm,
ClusterSilhouettes=paste(slist, collapse=', '),
stringsAsFactors=F
)
)
}
}
}
}
randTable
}
clustStats<-rbind(
summarizeSampleClusters(
data=ecpm, distm=distm, linkm=linkm, v=v, label='ecpm'
),
summarizeSampleClusters(
data=ecmb, distm=distm, linkm=linkm, v=v, label='ecmb'
)
)
